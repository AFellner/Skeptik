\documentclass{llncs}

\spnewtheorem*{notation}{Notation}{\bfseries}{\itshape}

\usepackage{bussproofs}
\def\defaultHypSeparation{\hskip.1in}

\usepackage{enumitem,amsmath,amssymb}

\usepackage{algorithm2e}

\newcommand{\dual}[1]{{\ensuremath{\bar{#1}}}}
\newcommand{\fix}{\ensuremath{\operatorname{fix}}}

% The following is to comment draft source file. It has to be deleted for the
% final document.
\usepackage{xcolor}
\newenvironment{jogo}{\color{teal}}{}

\title{Propositional Resolution Proof Compression by Lowering Nodes}
\author{Joseph Boudou \and Bruno Woltzenlogel Paleo}
\institute{Vienna University of Technology, Austria}

\begin{document}

\maketitle

\begin{abstract}
\begin{jogo}
  To do.
\end{jogo}
\end{abstract}

\section{Introduction}

\begin{jogo}
In this section we introduce the domain : first SAT then compression.
I could be a good idea to talk about the problem of measuring a proof.
We could explain the use case of verifying a proof and how we plan to measure its complexity.
\end{jogo}

\section{Propositional Resolution Calculus}

\begin{jogo}
In this section we introduce the definitions and notations we'll use trough this paper.

Here is a list of things to define (maybe elsewhere) : \begin{itemize}[nosep]
    \item variable, dual, literal, clause, node, proof
    \item premise, children, parent
    \item regularity (vertical and horizontal)
    \item safe literals
\end{itemize}
\end{jogo}

\begin{jogo}
I think we need to distinguish between variables and literals. There is only one curly lowercase
letter in standart \LaTeX ($\ell$) hence we can't use that. I propose to rely on usual conventions
for propositional logic and use uppercase roman letters for propositional variables. Literals would
be written in lowercase roman letters. Clauses still are written as uppercase greek letters and nodes
as lowercase greek letters.

What follows is a Cut-and-Paste from your paper. I don't know what has to be a definition or what
has to be written in a simple paragraph. Actually everything in this section reads like a
definition.
\end{jogo}

A \emph{literal} is a propositional variable or the negation of a propositional variable. We write
\dual{l} to denote the dual of $l$ (i.e. for all propositional variable $P$, $\dual{P} =
\neg P$ and $\overline{\neg P} = P$) and $|l|$ for the propositional variable underlying the literal
$l$ (i.e. $|P| = |\neg P| = P$). A \emph{clause} is a set of literals, $\bot$ denotes the
\emph{empty clause}.

\begin{notation}[Resolution]
Resolution of nodes $\eta_0$ and $\eta_1$ is written $\eta_0 \odot_a \eta_1$, $a$ being the pivot
literal such that $\bar{a} \in \eta_0$ and $a \in \eta_1$.
\end{notation}

\begin{definition}[Safe literal]
In a proof $\psi[\eta]$ of $\Sigma$, a literal $p$ is safe for the node $\eta$ proving $\Gamma$ if
for all proof $\eta'$ of $\Gamma \cup \{p\}$, $\psi[\eta']$ still proves $\Sigma$.
\end{definition}

\subsection{Proof as Directed Acyclic Graph}

\begin{jogo}
In this subsection I would like to introduce the DAG representation of proofs.  The set of proofs on
a set of axioms has to be defined for transformation to be clearly stated. I think we should have
three trnsformations : resolution $\odot$, deletion of a node from a proof, replacement of a node in
a proof. The two latter ones implies to introduce the fix operation in this subsection.
\end{jogo}

A proof of $\Gamma$ based on a set $\mathcal{A}$ of axioms is represented as an unordered tree-like
directed acyclic graphs. Leaves are axioms from $\mathcal{A}$ and inner nodes are resolution steps.
Edges are directed from the resolution node to its premises and are labeled by the premise's
auxiliary literal. Nodes are labeled by their conclusion. The root node's conclusion is $\Gamma$.

\begin{definition}[Proof] \label{def:proof}
Given a finite set $\mathcal{A}$ of clauses called axioms, the set $\mathcal{P_A}$ of proofs on
$\mathcal{A}$ are graphs $\langle \mathcal{V},\mathcal{E} \subset \mathcal{V} \times \mathcal{V},
f_\mathcal{V} : \mathcal{V} \longrightarrow 2^\mathcal{L}, f_\mathcal{E} : \mathcal{E}
\longrightarrow \mathcal{L}, \rho \in \mathcal{V} \rangle$ inductively defined as :
\begin{enumerate}[nosep]
  \item $\forall \Gamma \in \mathcal{A}$, $\langle \{\Gamma\}, \varnothing, \Gamma
    \rightarrow \Gamma, \varnothing, \Gamma \rangle$ is a proof of $\Gamma$.
  \item If $\psi_L = \langle V_L, E_L, f_{V_L}, f_{E_L}, \rho_L \rangle \in \mathcal{P_A}$ and
    $\psi_R = \langle V_R, E_R, f_{V_R}, f_{E_R}, \rho_R \rangle \in \mathcal{P_A}$ with $\psi_L
    \neq \psi_R$, then $\forall a \in \mathcal{L}$ such that $\dual{a} \in f_{V_L}(\rho_L)$ and $a
    \in f_{V_R}(\rho_L)$ and given a new node $\rho$ the graph $\psi = \langle V_L \cup V_R \cup
    \{\rho\}, E_L \cup E_R \cup \{(\rho,\rho_L),(\rho,\rho_R)\}, f_V, f_L, \rho \rangle$ with $f_V$
    defined as
    \begin{equation*}
      f_V(\eta) = \begin{cases}
        f_{V_L}(\eta) & \eta \in V_L \\
        f_{V_R}(\eta) & \eta \in V_R \\
        (f_{V_L}(\rho_L) \setminus \{\dual{a}\}) \cup (f_{V_R}(\rho_R) \setminus \{a\}) &
          \eta = \rho
      \end{cases}
    \end{equation*}
    and $f_L$ as
    \begin{equation*}
      f_E(\varsigma,\eta) = \begin{cases}
        f_{E_L}(\varsigma,\eta) & (\varsigma,\eta) \in E_L \\
        f_{E_R}(\varsigma,\eta) & (\varsigma,\eta) \in E_R \\
        \dual{a} & \varsigma = \rho \text{ and } \eta = \rho_L \\
        a        & \varsigma = \rho \text{ and } \eta = \rho_R
      \end{cases}
    \end{equation*}
    is a proof of $f_V(\rho)$. We write $\psi = \psi_L \odot_a \psi_R$.
  \qed
\end{enumerate}
\end{definition}

As the premises are unordered we have $\psi_L \odot_a \psi_R = \psi_R \odot_\dual{a} \psi_L$.
Furthermore, nodes are uniquely defined by their premises and conclusion. Hence there is a bijection
between nodes and proofs and we will often identify one with the other. Each node $\eta$ of a proof
is a subproof of its conclusion $f_V(\eta)$.

The following properties can easily be proved by induction for any proofs.

\begin{property}
\label{prop:proof_leaf}
Axioms are leaves : $\Gamma \in \mathcal{A} \cap V \Leftrightarrow \forall \eta \in V ,~
(\Gamma,\eta) \notin E$.
\end{property}

\begin{property}
Every inner node $\varsigma \in V \setminus \mathcal{A}$ has exactely two premises.
\end{property}

\begin{property}
\label{prop:proof_edges}
If a node $\varsigma \in V$ has two premises $\eta_L$ and $\eta_R$ then
\begin{equation*}
f_E(\varsigma,\eta_L) = \overline{f_E(\varsigma,\eta_R)}
\end{equation*}
\end{property}

\begin{property}
\label{prop:proof_conclusion}
\begin{equation*}
  f_V(\varsigma) = \begin{cases}
    \varsigma & \varsigma \text{ has no premise} \\
    \bigcup_{(\varsigma,\eta) \in E}{f_V(\eta) \setminus f_E(\varsigma,\eta)} & \text{otherwise}
  \end{cases}
\end{equation*}
\end{property}

\begin{property}
$(\varsigma,\eta) \in E \Rightarrow f_E(\varsigma,\eta) \in f_V(\eta)$.
\end{property}

\begin{property}
For all node $\eta$ different from $\rho$ there is a path from $\rho$ to $\eta$.
\end{property}

Conversely, if all those properties hold for a directed acyclic graph (DAG) then it is a proof,
modulo the identity of inner nodes.

\subsection{Proofs Transformations}

To reduce proofs' size we'll need to transform proofs. But many simple graph transformation like
deleting an edge will result in a DAG which isn't a proof anymore. We are particularly interested in
transformations which lead to DAG verifying the property \ref{prop:proof_edges} plus the following one.

\begin{property}
\label{prop:pseudo-proof}
Every node has at most two premises.
\end{property}

Such a DAG can be transformed into a proof by \emph{fixing} it as defined below.

\begin{definition}[Fixing]
Fixing a DAG $\langle V, E, f_V, f_E, \rho \rangle$ verifying properties \ref{prop:proof_edges} and
\ref{prop:pseudo-proof} into a proof on $\mathcal{A}$ consist in applying recursively the following
transformations until a fix-point is reached.
\begin{enumerate}
  \item Delete every node $\eta \in V \setminus \mathcal{A}$ which have no premise.
  \item For every node $\varsigma$ which have exactely one premise $\eta$, replace every incoming
    edge $(\theta,\varsigma)$ by $(\theta,\eta)$.
  \item Replace $f_V$ by a function verifying the property \ref{prop:proof_conclusion}.
  \item For every edge $(\varsigma,\eta)$ such that $f_E(\varsigma,\eta) \notin f_V(\eta)$, replace
    every edge $(\theta,\varsigma) \in E$ by $(\theta,\eta)$.
  \item Delete every node and every edge not reachable from $\rho$.
  \qed
\end{enumerate}
\end{definition}

\begin{jogo}
Do you think we need a proof of that or is it obvious ?
\end{jogo}

With the help of this fixing operation, we can easily define the deletion of a node in a proof and
the replacement of a node by another one.

\begin{definition}[Deletion of a node]
Deleting a node $\eta$ in a proof $\psi$ consist in deleting every edge $(\varsigma,\eta) \in E$ and
fixing the resulting DAG. It is written $\psi[\setminus \eta]$.
\end{definition}

\begin{definition}[Replacing a node]
Replacing a node $\eta$ in a proof $\psi$ by a node $\eta'$ (not necessirly in $V$) consist in
replacing every edge $(\varsigma,\eta) \in E$ by $(\varsigma,\eta')$ and fixing the resulting DAG.
It is written $\psi[\eta \leftarrow \eta']$.
\end{definition}


\section{LowerUnits}

When a node $\eta$ as more than one child in a proof $\psi$ it might be convenient to factor the
corresponding resolutions. Lowering $\eta$ is such a factorisation. A new equivalent proof is
constructed by removing $\eta$ from $\psi$, fixing the resulting DAG and then reintroducing $\eta$
at the bottom of the proof. Formaly, a node $\eta$ in a proof $\psi$ of $\Gamma$ can be lowered if
there exists a proof $\psi'$ of $\Gamma$ and a literal $a$ such that $\psi' = \psi[\setminus \eta]
\odot_a \eta$.

These idea has been introduce in \cite{LURPI} for the LowerUnits algorithm. Units are nodes with a
conclusion consisting of only one literal. Such nodes can always be lowered. The proposed algorithm
lowers every unit with more than one child. Care is taken to reintroduce units in an order
corresponding to the transitive closure of the premise relation : if a unit $\eta$ is a parent of a
unit $\varsigma$ then $\eta$ has to be reintroduced after (ie below) $\varsigma$.

A possible implementation of LowerUnits is shown in Algorithm \ref{algo:LU}. Units are collected during a
first traversal. As this traversal is bottom-up, units are stored in a queue. The traversal could
have been top-down and units stored in a stack. Units are effectively removed during a second,
top-down traversal. The last step is the reintroduction of units.

\begin{algorithm}[tb]
  Units $\leftarrow \varnothing$ \;

  \For{every node $\eta$ in a bottom-up traversal}{
    \If{$\eta$ is a unit with more than one child}{Enqueue $\eta$ in Units \; }
  }

  \For{every node $\varsigma$ in a top-down traversal}{
    \uIf{a premise $\eta$ of $\varsigma$ belongs to Units}{
      Replace $\varsigma$ by $\eta$ \; }
    \Else{
      Recompute $\varsigma$'s conclusion based on the current premises \; }
  }

  $\rho \leftarrow$ the new root of the proof \;
  \For{every unit $\upsilon$ in Units}{
    Let $\{u\}$ be $\upsilon$'s conclusion \;
    \lIf{$\rho$'s conclusion contains $\dual{u}$}{
    $\rho \leftarrow \rho \odot_u \upsilon$ \;}
  }

  \label{algo:LU}
  \caption{A possible LowerUnit implementation}
\end{algorithm}

LU has been successfully composed with the RecyclePivotsWithIntersection (RPI) algorithm presented in
\cite{LURPI}. Both sequential compositions achieve very good compression ratio in reasonnable amount
of time. Unfortunately, none of them is always better than the other and there is actually no
heuristic to choose which one to apply a priori.

\section{LoweringUnivalents}

\begin{jogo}
This is the main section. First we define univalent clause and we prove that it's not sufficent for
a node to be lowered. Second we introduce active literals and the main theorem (with proof). Third
we explain the partial regularization done by "Deletable" nodes. Fourth we give the algorithm. Fifth
we prove it's always better than LowerUnits.
\end{jogo}

We would like to extend LowerUnits presented in \cite{LURPI}. Intuitively,
if a node with a clause $a$ is already marked to be lowered, another node with
a clause $\bar{a},b$ might be lowered too.

The problem of lowering a node $\eta$ in a proof of the form
\begin{equation}
\psi[\eta] \odot_{a_0} \eta_0 \odot_{a_1} \cdots \odot_{a_n} \eta_n
\end{equation}
is to decide whether a literal $a$ such that the proof 
\begin{equation}
\text{Fix}\left(\psi[]\right) \odot_a \eta \odot_{a_0} \eta_0 \odot_{a_1} \cdots \odot_{a_n} \eta_n
\end{equation}
is equivalent to
the original proof exists.
\subsection{Univalent Clauses}

The extended unit concept intuitively presented above can be formely defined as
univalent clause.

\begin{definition}[Valent literal]
A literal $a$ is said to be valent w.r.t. a clause $\Delta$ iff $\bar{a}$ does
not occur in $\Delta$.
\end{definition}

\begin{definition}[Univalent clause]
A clause $\Gamma$ is said to be univalent w.r.t. another clause $\Delta$ iff
there is exactly one literal $a$ in $\Gamma$ which is valent w.r.t. $\Delta$.
\end{definition}

Units have univalent clause w.r.t. a clause $\Delta$ unless their sole literal
is a dual of a $\Delta$'s literal. Therefore univalent clauses are not a
strict extension of units.


\subsection{Lowering Nodes with Univalent Clause}

The question now is whether nodes with a univalent clause w.r.t. the clause of
lowered pivots can be lowered.

Actually this isn't always the case. For example let's consider a node
$\eta$ with clause $a,b$, the clause $\Delta$ of lowered pivots being
$\bar{a}$. Obviously, $\eta$'s clause is univalent. But if an $\eta$'s
direct child has $a$ as pivot, removing $\eta$ from $\psi$ will introduce
the literal $\bar{a}$ which will propagate down the proof.

Hence we need a condition on the children of the node we want to lower.

\begin{definition}[Active literal]
Let's consider a node $\eta$ with clause $\Gamma$. A literal $a$ from
$\Gamma$ is said to be an active literal of $\eta$ iff $a$ is the pivot of
one of $\eta$'s child.
\end{definition}

\begin{theorem}
If all the active literals of a node $\eta$ with clause $\Gamma$ univalent
w.r.t. the clause $\Delta$ of lowered literals either are the valent
literal $a$ or belong to $\Delta$, then $\eta$ can be lowered.
\end{theorem}

\begin{proof}
Let $\bar{\Delta}$ be the clause of all $\Delta$'s literals duals.
$\psi[\eta]$'s clause subsumes $\bar{\Delta}$. For $\eta$ to be lowerable,
the conclusion of $\psi[] \odot_a \eta$ has to subsume $\bar{\Delta}$ too.

By removing $\eta$ from $\psi$ only the dual of every $\eta$'s active literal
might be introduced. If the active literal is $a$, its dual will be removed
by the resolution on $a$. If the active literal belongs to $\Delta$, its
dual belongs to $\bar{\Delta}$.
\qed
\end{proof}

\section{Experiments}

\begin{jogo}
LU vs LUniv ; RPI[3]LU vs RPI[3]LUniv ; LUnivRPI vs LU.RPI.
\end{jogo}

\section{Conclusions}

\bibliographystyle{splncs}
\bibliography{../biblio}

\end{document}
