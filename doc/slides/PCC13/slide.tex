\documentclass[compress]{beamer}
\setbeamercovered{transparent}
%\useoutertheme{infolines}
%\useoutertheme[footline=authortitle,subsection=false]{miniframes}
\setbeamertemplate{navigation symbols}{}

\definecolor{vertmoyen}{HTML}{A9CB60}
\definecolor{vertclair}{HTML}{D3F192}
\definecolor{vertfonce}{HTML}{347003}
\definecolor{deletecol}{HTML}{3B8A13}
\definecolor{addcolor} {HTML}{9E0270}

\usecolortheme[named=vertfonce]{structure}

\setbeamercolor{section in head/foot}{fg=vertfonce,bg=vertmoyen}
\setbeamercolor{subsection in head/foot}{bg=vertclair}

\setbeamercolor{author in head/foot}{fg=vertfonce, bg=vertclair}
\setbeamercolor{title in head/foot}{fg=vertfonce, bg=vertmoyen}
\setbeamercolor{date in head/foot}{fg=vertfonce, bg=vertclair}

\setbeamercolor{separation line}{bg=vertfonce}


\setbeamercolor{titlelike}{bg=vertclair}
\setbeamerfont{frametitle}{size=\normalsize}

\makeatletter

\defbeamertemplate*{frametitle}{jogo theme}
{
  \ifbeamercolorempty[bg]{frametitle}{}{\nointerlineskip}%
  \ifx\insertsectionhead\@empty\usebeamerfont{headline}\vspace{-3.45ex}\fi%
  \@tempdima=\textwidth%
  \advance\@tempdima by\beamer@leftmargin%
  \advance\@tempdima by\beamer@rightmargin%
  \begin{beamercolorbox}[left,wd=\the\@tempdima]{frametitle}
    \usebeamerfont{frametitle}%
%    \vbox{}\vskip-0.5ex%
%    \if@tempswa\else\csname beamer@fte#1\endcsname\fi%
    \strut\hspace{1em}\insertframetitle\strut\par%
    {%
      \ifx\insertframesubtitle\@empty%
      \else%
      {\usebeamerfont{framesubtitle}\usebeamercolor[fg]{framesubtitle}\insertframesubtitle\strut\par}%
      \fi
    }%
%    \vskip-1ex%
%    \if@tempswa\else\vskip-.3cm\fi% set inside beamercolorbox... evil here...
  \end{beamercolorbox}%
}

\defbeamertemplate*{headline}{jogo theme}
{
    \leavevmode%
  \ifx\insertsectionhead\@empty\vspace{3.45ex}%
  \else%
  {%
    \hbox{%
    \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,right]{section in head/foot}%
      \usebeamerfont{section in head/foot}\insertsectionhead\hspace*{2ex}
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,left]{subsection in head/foot}%
      \usebeamerfont{subsection in head/foot}\hspace*{2ex}\insertsubsectionhead
    \end{beamercolorbox}%
    }%
    \vskip0pt%
    \begin{beamercolorbox}[wd=\paperwidth,colsep=.05ex]{separation line}
    \end{beamercolorbox}
  }%
  \fi
}

\defbeamertemplate*{footline}{jogo theme}
{
  \leavevmode%
    \begin{beamercolorbox}[wd=\paperwidth,colsep=.05ex]{separation line}
    \end{beamercolorbox}
  \hbox{%
  \begin{beamercolorbox}[wd=.25\paperwidth,ht=2.25ex,dp=1ex,left]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.25\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
    \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
    \insertframenumber{} / \inserttotalframenumber\hspace*{2ex} 
  \end{beamercolorbox}}%
  \vskip0pt%
}

\makeatother

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{kpfonts}

\usepackage{amsmath}

\newcommand{\dual}[1]{\ensuremath{\bar{#1}}}

\newcommand{\set}[2]{\ensuremath{\left\{#1\mid#2\right\}}}

\newenvironment<>{subpart}[1]
{ \begin{block}#2{#1}
  \begin{itemize}
}{
  \end{itemize}
  \end{block}
}

\newcommand<>{\singleline}[1]{\begin{block}{\only#2#1}\end{block}}

\usepackage{bussproofs}
\newcommand{\Resolution}[2]{\RightLabel{\footnotesize{$#1$}} \BinaryInfC{$#2$}}

\usepackage[vlined]{algorithm2e}

\usepackage{multicol}

\usepackage{tikz}
\usetikzlibrary{positioning}

\newcommand{\basecharttitle}[1]{{\color{vertfonce}#1}\vspace{-0.8em}}
\makeatletter
\newcommand{\charttitle}{\@ifstar\charttitlestar\charttitleplain}
\makeatother
\newcommand{\charttitleplain}[1]{\hspace{2em}\basecharttitle{#1}}
\newcommand{\charttitlestar}[1]{\centering\basecharttitle{#1}}

\newcommand{\compC}{Compression ratio comparison}
\newcommand{\timeC}{Compression time comparison \scriptsize (in seconds)}
\newcommand{\axioC}{Axiom compression ratio comparison}

\newcommand{\asGoodRPILU}{For a combined algorithm to be always at least as
good as RPI.LU it has to compute root and units safe literals.}
\newcommand{\asGoodLURPI}{For a combined algorithm to be always at least as
good as LU.RPI it has to be able to lower units introduced by RPI.}

\newcommand{\bottomup}{\item[$\uparrow$]}
\newcommand{\topdown} {\item[$\downarrow$]}
\newcommand{\anydir}  {\item[$\updownarrow$]}

\newcommand{\chartscale}{1}

\tikzstyle{proof edge}=[->,thick,cap=round]
\tikzstyle{deleted edge}=[proof edge, dashed, color=deletecol]

\newcommand{\proofnode}[3][]{
  \node [anchor=mid, #1] (#2) {#3}
}

\newcommand{\rootnode}[1][]{
  \proofnode[#1]{root}{$\bot$}
}

\newcommand<>{\edgewithlabel}[3]{
  \draw#4 [proof edge, color=vertfonce] (#1) -- (#2) node [above, pos=0.3] {\footnotesize #3}
}

\newcommand<>{\drawchildren}[3]{
  \draw#4 [proof edge] (#1) -- (#2);
  \draw#4 [proof edge] (#1) -- (#3)
}

\newcommand{\addchildren}[5]{
  \proofnode[above left  of=#1]{#2}{#3};
  \proofnode[above right of=#1]{#4}{#5}
}

\newcommand{\withchildren}[5]{
  \addchildren{#1}{#2}{#3}{#4}{#5};
  \drawchildren{#1}{#2}{#4}
}

\newcommand<>{\crossnode}[2][]{
  \draw#3 [color=deletecol,thick,cap=round,#1] (#2.mid) ++(10:0.3) -- ++(190:0.6);
}

\newcommand<>{\pivot}[3][]{
  \node#4 [anchor=base,color=vertfonce,#1] at (#2.north) {\scriptsize #3};
}

\newcommand<>{\safelit}[3][]{
  \node#4 [anchor=west,color=vertfonce,#1] at (#2.mid) {\hspace{0.2em} \scriptsize $\left\{#3\right\}$};
}

\title[Compression of Propositional Resolution Proofs]{Compression of Propositional Resolution Proofs by Lowering Subproofs}
\author[J. Boudou, B. Woltzenlogel Paleo]{
  Joseph Boudou\inst{1}
  \and 
  Bruno Woltzenlogel Paleo\inst{2}
}
\institute{
  \inst{1}Universit\'e Paul Sabatier, Toulouse
  \and 
  \inst{2}Vienna University of Technology
}
\date[PCC 2013]{PCC Workshop, 2013}

\includeonly{}
%%%%%%%%%%%%%%%%%%
% Begin Document %
%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{frame}[plain]
\titlepage
\end{frame}

\begin{frame}{Overview}
\tableofcontents
\end{frame}

\section{Introduction}

\subsection{Propositional resolution calculus}


\begin{frame}
\begin{subpart}{Literals}
  \item A \emph{literal} is an atomic formula or the negation of an atomic formula.
  \item The dual of a literal $\ell$, denoted by $\dual{\ell}$, is such that
        $\dual{p} = \neg p$ and $\dual{\neg p} = p$.
\end{subpart}
\begin{subpart}{Clauses}
  \item A \emph{clause} is a disjonctive set of literals.
  \item The empty clause corresponds to false.% and is denoted by $\bot$.
  \item Tautologies contain both a literal $\ell$ and its dual $\dual{\ell}$.
\end{subpart}
%\begin{subpart}{Instance}
%  \item An \emph{instance} is a conjonctive set of clauses.
%\end{subpart}
%  \begin{subpart}{SAT context}
%    \item Axioms are instance's clauses.
%    \item Proofs of unsatisfiability.
%    \item Tautologies are prohibited.
%  \end{subpart}
  \begin{block}{Robinson's Resolution Principle}
    \vspace{-.5em}
    \begin{prooftree}
      \AxiomC{$\Gamma, \dual{\ell}$}
      \AxiomC{$\ell, \Delta$}
      \Resolution{\ell}{\Gamma, \Delta}
    \end{prooftree}
  \end{block}
\end{frame}

\subsection{Proofs as DAG}

\begin{frame}
  \begin{block}{Proof as a tree}
    \vspace{-.5em}
    \begin{prooftree}
      \AxiomC{$\dual{b}, c$}
      \AxiomC{$\dual{a}, b$}
      \Resolution{b}{\dual{a}, c}
      \AxiomC{$\dual{a}, b$}
      \AxiomC{$\dual{a}, \dual{b}, \dual{c}$}
      \Resolution{\dual{b}}{\dual{a}, \dual{c}}
      \Resolution{\dual{c}}{\dual{a}}
      \AxiomC{$a$}
      \Resolution{a}{\bot}
    \end{prooftree}
  \end{block}
  \begin{block}{Proof as a directed acyclic graph (DAG)}
    \vspace{.5em}
      \centering
      \begin{tikzpicture}[node distance=1.2cm]
        \rootnode;
        \withchildren{root} {r0}{\dual{a}}  {unit}{a};
        \withchildren{r0}   {r1}{\dual{a},c} {r2}{\dual{a},\dual{c}};
        \withchildren{r1}   {a0}{\dual{b},c} {low}{\dual{a},b};
        \proofnode[above right of=r2] {a1} {\dual{a},\dual{b},\dual{c}};
        \drawchildren {r2} {low} {a1};
      \end{tikzpicture}
  \end{block}
\end{frame}

\newcommand{\edge}[3]{\ensuremath{#1 \xrightarrow{#2} #3}}

\begin{frame}
  \begin{definition}[Proof]
    A graph $\varphi = \langle V, E, L \rangle$ where $V$ is a set of node,
    $E \subset V \times \mathcal{L} \times V$ a set of edges labeled by literals and $L: V
    \longrightarrow 2^\mathcal{L}$ an edge labeling function, is a proof of $\Gamma$ iff either : \begin{itemize}
    \item $v$ is a new node, $V=\{v\}$, $E=\varnothing$ and $L=\{ v \longmapsto \Gamma \}$;
    \item $\varphi_L = \langle V_L, E_L, L_L \rangle$ is a proof of $\Gamma_L$, $\varphi_R = \langle V_R, E_R, L_R \rangle$
      is a proof of $\Gamma_R$, $\ell$ is a literal s.t. $\dual{\ell} \in \Gamma_L$ and $\ell \in
      \Gamma_R$, $v$ is a new node and \begin{align*}
        V &= V_L \cup V_R \cup \{v\} \\
        E &= E_L \cup E_R \cup
             \{ \edge{v}{\dual{\ell}}{\rho(\varphi_L)}, \edge{v}{\ell}{\rho(\varphi_R)} \} \\
        L &= L_L \cup L_R \cup \{v \longmapsto \Gamma\} \\
   \Gamma &= \left( \Gamma_L \setminus \{\dual{\ell}\} \right) \cup
             \left( \Gamma_R \setminus \{\ell\} \right)
      \end{align*} where $\rho(\varphi)$ denotes the root of $\varphi$.
    \end{itemize}
  \end{definition}
\end{frame}

\begin{frame}
  \begin{definition}[Directed Acyclic Graph with root]
    A graph $\gamma = \langle V, E, L \rangle$ where $V$ is a set of node,
    $E \subset V \times X \times V$ a set of labeled directed edges and $L: V
    \longrightarrow Y$ a node labeling function, is a directed acyclic graph with root iff
    there exists a node $\rho(\gamma)$ such that each other node is reachable from $\rho(\gamma)$
    but $\rho(\gamma)$ is not reachable from any node.
  \end{definition}

  \begin{definition}[Proof]
    A directed acyclic graph $\langle V, E, L \rangle$ where $V$ is a set of node,
    $E \subset V \times \mathcal{L} \times V$ a set of edges labeled by literals and $L: V
    \longrightarrow 2^\mathcal{L}$ an edge labeling function, is a proof iff it is inductively
    constructible according to the following cases : \begin{itemize}
    \item if $\Gamma$ is a clause then $\langle \{v\}, \varnothing, v \longmapsto \Gamma \rangle$ is a
      proof for any new $v$;
    \item if $\langle V_L, E_L, L_L \rangle$ and $\langle V_R, E_R, L_R \rangle$ are proofs and
      for a given literal $\ell$, $\ell \in L$
    \end{itemize}
  \end{definition}
\end{frame}


\begin{frame}{Proof as DAG}
  \begin{definition}[Proof]
    A proof is a tuple $\langle V, E, \lambda_V, \lambda_E, \rho \rangle$ s.t.: \begin{itemize}
    \item $\langle V, E \rangle$ is a directed acyclic graph (DAG);
    \item $\lambda_V$ is a function labeling nodes with clauses;
    \item $\lambda_E$ is a function labeling edges with literals;
    \item $\rho \in V$ and $\forall \eta \in V \setminus \{\rho\}$, a path exists from $\rho$ to $\eta$;
    \item for each incoming edge $\edge{\eta'}{\ell}{\eta}$, $\ell \in \lambda_V(\eta)$;
    \item a node $\eta \in V$ without any outgoing edge is called an axiom;
    \item a node $\eta$ with exactely two outgoing edges $\edge{\eta}{\ell_L}{\eta_L}$ and
          $\edge{\eta}{\ell_R}{\eta_R}$ is called a resolution step and is s.t. $\dual{\ell_L} = \ell_R$ and
          $ \lambda_V(\eta) = \left( \lambda_V(\eta_L) \setminus \{ \ell_L \} \right)
                         \cup \left( \lambda_V(\eta_R) \setminus \{ \ell_R \} \right) $;
    \item each node $\eta \in V$ is either an axiom or a resolution step.
    \end{itemize}
  \end{definition}
\end{frame}
    

\begin{frame}{Subproofs}
  \begin{definition}[Subproof]
    A proof $\psi' = \langle V', E', \lambda_V', \lambda_E', \rho' \rangle$ is a subproof of a proof
    $\psi = \langle V, E, \lambda_V, \lambda_E, \rho \rangle$ iff there exists an injective
    function $f$ from $V'$ to $V$ such that: \begin{itemize}
    \item $\forall \eta' \in V',~ \lambda_V'(\eta') = \lambda_V(f(\eta'))$;
    \item $\forall (\eta_F', \eta_T') \in E',~ (f(\eta_F'), f(\eta_T')) \in E$ and
          $\lambda_E'(\eta_F', \eta_T') = \lambda_E(f(\eta_F'), f(\eta_T'))$;
    \end{itemize}
  \end{definition}
  \begin{subpart}{Properties}
    \item Subproof is a partial order relation on proofs, noted $\sqsubseteq$.
    \item The relation $\equiv$ such that
          $\psi' \equiv \psi \Leftrightarrow \psi' \sqsubseteq \psi \wedge \psi \sqsubseteq \psi'$
          is an equivalence relation on proofs.
  \end{subpart}
\end{frame}

\begin{frame}{Resolution operator}
  \begin{definition}
    TODO
  \end{definition}
\end{frame}

\section{Redundancies and corresponding algorithms}

\frame{\tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/show/hide]}

\subsection{Vertical redundancy}

\begin{frame}{Regular proof}
\begin{definition}[Tseitin 1970]
  A proof is regular iff on every path from its root to any of its axiom, any literal
  appears at most once as edge label.
\end{definition}
\begin{theorem}[Goerdt 1990]
  Given a set of axioms and a clause $\Gamma$, the smallest regular proof of $\Gamma$ might be exponentialy bigger
  than the smallest irregular proof of $\Gamma$.
\end{theorem}
\end{frame}

\begin{frame}{RecyclePivotsWithIntersection (RPI)}
  \begin{subpart}{Partial Regularization}
    \item Delete an outgoing edge labeled with $\ell$ iff $\dual{\ell}$ appears on \textbf{every} path from the root to the node.
  \end{subpart}
  \begin{definition}[Safe literal]
    A literal is safe for a node $\eta$ if it can be added to $\eta$'s clause without changing proof's conclusion.
  \end{definition}
  \begin{subpart}{Two traversals}
    \bottomup Collect safe literals and mark edges to delete.
    \topdown Delete edges and fix the proof.
  \end{subpart}
\end{frame}

\begin{frame}
  \begin{columns}
    \alt<3->{\column{0.5\textwidth}}{\column{1\textwidth}}
    \begin{center}
    \begin{tikzpicture}[node distance=1.5cm]

      \rootnode;
      \addchildren{root} {a4}{$\dual{c}$} {r2}{$c$};
      \draw [proof edge] (root) -- (a4);
      \draw<1> [proof edge] (root) -- (r2);
      \edgewithlabel<2->{root}{r2}{$c$};

      \withchildren{r2} {r0}{$b$} {r1}{$\dual{b},c$};

      \withchildren{r0} {a0}{$\dual{a},b$} {iu}{$a$};

      \addchildren{iu} {a2}{$a,\dual{c}$} {a1}{$a,c$};
      \draw [proof edge] (iu) -- (a2);
      \draw<1> [proof edge] (iu) -- (a1);
      \edgewithlabel<2->{iu}{a1}{$c$};

      \proofnode[above right of=r1]{a3}{$\dual{a},\dual{b},c$};
      \draw [proof edge] (r1) -- (a3);
      \draw [proof edge] (r1) -- (iu);
    \end{tikzpicture}
    \only<3->{Original proof}
    \end{center}
%    \begin{onlyenv}<3->
    \only<3->{
    \column{0.5\textwidth}
    \begin{center}
    \begin{tikzpicture}[node distance=1.5cm]

      \rootnode;
      \withchildren{root} {a4}{$\dual{c}$} {r2}{$c$};

      \withchildren{r2} {r0}{\alt<4>{$b,c$}{$b$}} {r1}{$\dual{b},c$};

      \withchildren{r0} {a0}{$\dual{a},b$} {iu}{\alt<4>{$a,c$}{$a$}};

      \addchildren{iu} {a2}{$a,\dual{c}$} {a1}{\alt<4>{$a$}{$a,c$}};
      \draw<3> [deleted edge] (iu) -- (a2);
      \draw<3> [proof edge] (iu) -- (a1);

      \proofnode[above right of=r1]{a3}{$\dual{a},\dual{b},c$};
      \draw [proof edge] (r1) -- (a3);
      \draw [proof edge] (r1) -- (iu);

      \crossnode<4>{a2}
      \crossnode<4>{a1}
    \end{tikzpicture}
    Compressed proof
    \end{center}
  }
%    \end{onlyenv}
  \end{columns}
\end{frame}


\subsection{Horizontal redundancy}

\begin{frame}{Extending Irregularity}
\begin{definition}[Fully regular proof]
  A proof is fully regular if for each variable there is at most one resolution node with this variable as pivot.
\end{definition}
\begin{subpart}{Conventions}
  \item Usual irregularities are called \emph{vertical irregularities}.
  \item Other irregularities are called \emph{horizontal irregularities}.
\end{subpart}
\end{frame}

\begin{frame}{LowerUnits (LU)}
  \begin{subpart}{Lowering}
    \item Moving a node down the proof to resolve it only once.
  \end{subpart}
  \begin{subpart}{Lowering Units}
    \item Units can always be lowered.
    \item Reduces horizontal irregularities.
  \end{subpart}
  \begin{subpart}{Two traversals}
    \anydir Collect units with more than one child.
    \topdown Delete units, fix the proof and then reintroduce the units at the bottom of the proof.
  \end{subpart}
\end{frame}

\begin{frame}{Sequential Composition}
\centering
\charttitle{\compC}
\include{composition-chart}
\end{frame}


\section{Difficulties}
\subsection{to find a combined algorithm always at least as good as both compositions}

\begin{frame}{Irregular Units}
  \begin{center}
\begin{tikzpicture}[node distance=1.3cm]
  \proofnode[color=addcolor]{luroot}{\only<4>{$\bot$}};

  \proofnode[above left of=luroot]{root}{\alt<3-4>{$\dual{a}$}{$\bot$}};
  \withchildren{root} {r2}{\alt<3-4>{$\dual{a} c$}{$c$}} {a4}{$\dual{c}$};
  \withchildren{r2} {r0}{\alt<8>{$b c$}{$b$}} {r1}{$\dual{b} c$};

  \addchildren{r0} {a0}{$\dual{a} b$} {iu}{$a$};
  \draw [proof edge] (r0) -- (a0);
  \only<1,5->{\draw [proof edge] (r0) -- (iu);}
  \only<2>{\draw [deleted edge] (r0) -- (iu);}

  \addchildren{iu} {a1}{$a c$} {a2}{$a \dual{c}$};
  \draw [proof edge] (iu) -- (a1);
  \only<1-6>{\draw [proof edge] (iu) -- (a2);}
  \only<7>{\draw [deleted edge] (iu) -- (a2);}

  \proofnode[above right of=r1]{a3}{$\dual{a} \dual{b} c$};
  \draw [proof edge] (r1) -- (a3);
  \only<1,5->{\draw [proof edge] (r1) -- (iu);}
  \only<2>{\draw [deleted edge] (r1) -- (iu);}

  \crossnode<3-4>{r0}
  \crossnode<3-4>{r1}
  \only<4>{
    \draw [proof edge,color=addcolor] (luroot) -- (root);
    \draw [proof edge,color=addcolor] (luroot) .. controls ++(1.2,1.5) .. (iu);
  }

  \pivot<6>{iu}{$c$}
  \pivot<6>{root}{$c$}
  \safelit<7>{root}{}
  \safelit<7>{r2}{c}
  \safelit<7>{r0}{b,c}
  \safelit<7>{r1}{\dual{b},c}
  \safelit<7>{iu}{a,c}
  \crossnode<8>{a2}
  \crossnode<8>{iu}

  \draw (luroot) ++(1.2,-0.5) node {};
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}{Root and Units Safe Literals}
\begin{subpart}{In RPI.LU, after LU :}
  \item the proof is of the form $\eta \odot_{a_0} \eta_0 \odot_{a_1} \cdots \odot_{a_n} \eta_n$ ;
  \item $\set{\dual{a}_i}{i \leq n}$ is the safe literals for $\eta$ : \emph{the root's safe literals} ;
  \item $\forall i < n$, $\set{\dual{a}_j}{i < j \leq n}$ is the safe literals for $\eta_i$.
\end{subpart}
\begin{overlayarea}{\textwidth}{2em}
  \singleline<2->{\asGoodRPILU}
\end{overlayarea}
\end{frame}

\begin{frame}{Units introduced by RPI}
\begin{center}
\vspace{-3em}
\begin{tikzpicture}[node distance=1.3cm,scale=0.93]
  \rootnode;
  \addchildren{root} {n0}{\alt<3->{$\bot$}{$d$}} {a0}{$\dual{d}$};
  \draw<-2> [proof edge] (root) -- (n0);
  \draw     [proof edge] (root) -- (a0);
  \withchildren{n0} {n1}{\alt<3->{$e$}{$d e$}} {n2}{\alt<3->{$\dual{e}$}{$d \dual{e}$}};

  \withchildren{n1} {a1}{$\dual{b} e$} {u0}{\alt<3->{\alert<3>{$b$}}{$d b$}};
  \proofnode[above right of=n2]{a2}{$\dual{b} \dual{e}$};
  \drawchildren{n2} {u0} {a2};

  \withchildren{u0} {n3}{$a b d$} {a3}{$\dual{a} b$};
  \addchildren{n3} {n4}{$b d c$} {a4}{$\dual{c} a$};
  \draw    [proof edge]   (n3) -- (n4);
  \draw<-2>[proof edge]   (n3) -- (a4);
  \addchildren{n4} {a5}{$a b$}   {a6}{$\dual{a} d c$};
  \draw    [proof edge]   (n4) -- (a5);
  \draw<1> [proof edge]   (n4) -- (a6);
  \draw<2> [deleted edge] (n4) -- (a6);

  \pivot<2>{u0} {$a$}
  \pivot<2>{n4} {$a$}
  \crossnode<3->{a6}

  \crossnode<3->{n4}
  \crossnode<3->{n3}
  \crossnode<3->{a4}
  \crossnode<3->{root}
  \crossnode<3->{a0}
\end{tikzpicture}
\vspace{-2.2em}
\end{center}
\begin{overlayarea}{\textwidth}{1em}
  \singleline<4>{\asGoodLURPI}
\end{overlayarea}
\end{frame}


\section{Combined Equivalents}
\subsection{to both sequential compositions}

\begin{frame}{RPI[3]LU}
\singleline{\asGoodRPILU}
\begin{subpart}{Three traversals}
  \topdown  collect units and compute root and units safe literals ;
  \bottomup compute safe literals and mark edges to be deleted ;
  \topdown  fix the proof and reintroduce units.
\end{subpart}
\end{frame}

\begin{frame}{RPI[3]LU vs RPI.LU}
\centering
\only<+>{\charttitle{\compC} \include{3pass-compress}}
\only<+>{\charttitle{\timeC} \include{3pass-time}}
\end{frame}

\begin{frame}{LUnivRPI}
\begin{subpart}{\asGoodLURPI}
  \item Collect units during fixing (top-down traversal).
\end{subpart}
\addtocounter{beamerpauses}{1}
\begin{subpart}{Problems}<+->
  \item<.-> If a unit $\{a\}$ depends on a unit $\{b\}$ it'll be seen as $\left\{a, \dual{b}\right\}$.
  \item<+-> What to do if we find $\left\{a, \dual{b}\right\}$ after $\{b\}$ ?
  \item<+-> A new algorithm extending LU is needed.
\end{subpart}
\end{frame}

\section{LowerUnivalents}
\subsection{A new algorithm extending LU}

\begin{frame}{Lowering a node}
  \begin{subpart}{The (generalized) problem}
    \item Given $\psi[\eta] \odot_{a_0} \eta_0 \odot_{a_1} \cdots \odot_{a_{n-1}} \eta_{n-1}$
    \item is $\text{Fix}\left(\psi[]\right) \odot_a \eta \odot_{a_0} \eta_0 \odot_{a_1} \cdots \odot_{a_{n-1}} \eta_{n-1}$ equivalent ?
  \end{subpart}
  \begin{subpart}{Two steps}
    \item Deleting the node : $\text{Fix}\left(\psi[]\right)$ ;
    \item Reintroducing it : $\odot_a \eta$.
  \end{subpart}
  \begin{subpart}{Beware of introduced literals}
    \item $\Delta = \set{\dual{a}_i}{i < n}$ is the safe literals of $\text{Fix}\left(\psi[]\right) \odot_a \eta$.
  \end{subpart}
\end{frame}

\begin{frame}{Conditions}
\begin{subpart}{Literals introduced by reintroducing the node}
  \item Let $\Gamma_+$ be $\eta$'s clause,
  \item $\Gamma \setminus \Delta = \{a\}$.
\end{subpart}
\begin{definition}[Active literal]
Let's consider a node $\eta$ with clause $\Gamma_+$. A literal $a$ from
$\Gamma_+$ is said to be an active literal of $\eta$ iff $a$ is the pivot of
one of $\eta$'s child.
\end{definition}
\begin{subpart}{Literals introduced by deleting the node}
  \item Let $\Gamma_-$ be the set of the duals of $\eta$'s active literals,
  \item $\Gamma_- \setminus \Delta = \{\dual{a}\}$.
\end{subpart}
\end{frame}

\begin{frame}{Partial regularization}
\begin{subpart}{Deletable node \uncover<3->{(implemented)}}
  \item If $\Gamma_- \setminus \Delta = \varnothing$ then delete $\eta$.
\end{subpart}
\begin{subpart}<2->{Partial regularization \uncover<3->{(not implemented)}}
  \item If the dual of any of $\eta$'s active literal belongs to $\Delta$ then delete the edge.
\end{subpart}
\end{frame}

\begin{frame}{Algorithm}
  \SetKw{aElseIf}{else if}
  \SetKwFor{And}{and}{then}{endif}
  \begin{algorithm}[H]
    $\Delta \leftarrow \varnothing$ \;
    \For{every node $\eta$ in a top-down traversal}{
      Fix $\eta$ \;
      Compute $\Gamma_- \setminus \Delta$ \;
      \uIf{$\Gamma_- \setminus \Delta = \varnothing$}{Delete $\eta$ \;}
    \aElseIf{$\Gamma_- \setminus \Delta = \left\{\dual{a}\right\}$}
    \And{$\Gamma_+ \setminus \Delta = \{a\}$}{
        Lower $\eta$ \;
        $\Delta \leftarrow \Delta \cup \{ a \}$ \;
      }
     }
  \end{algorithm}
\end{frame}

\begin{frame}{Comparison with LU}
\centering
\only<+>{\charttitle{\compC} \include{LUniv-compress}}
\only<+>{\charttitle{\axioC} \include{LUniv-axiom}}
\only<+>{\charttitle{\timeC} \include{LUniv-time}}
\end{frame}

\appendix

\begin{frame}{Conclusion}
\charttitle*{Compression ratio comparison}
\renewcommand{\chartscale}{0.85}
\begin{columns}

  \column{0.45\textwidth}
  \centering
  \include{composition-chart}

  \column{0.55\textwidth}
  \centering
  \only<+>{\include{combination-chart}}
  \only<+>{\include{combluniv-chart}}
  
\end{columns}
\end{frame}

\begin{frame}{References}

\begin{subpart}{Skeptik}
\item http://github.com/Paradoxika/Skeptik
\end{subpart}

\begin{subpart}{Bibliography}
\item Fontaine, P., Merz, S., Woltzenlogel Paleo, B.: Compression of
  propositional resolution proofs via partial regularization. In: CADE. Lecture
  Notes in Computer Science, vol. 6803, pp. 237--251. Springer (2011)
\end{subpart}

\end{frame}

\end{document}
% vim: tw=100
